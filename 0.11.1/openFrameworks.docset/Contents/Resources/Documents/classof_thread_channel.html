<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="generator" content="Doxygen 1.8.3.1"/>
    <a class="dashingAutolink" name="autolink-270"></a><a class="dashAnchor" name="//apple_ref/cpp/Package/openFrameworks%3A%20Class%20Index"></a><title>openFrameworks: Class Index</title>
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="search/search.js"></script>
    <script type="text/javascript">
      $(document).ready(function() { searchBox.OnSelectItem(0); });
    </script>
    <link href="doxygen.css" rel="stylesheet" type="text/css"/>
  </head>
  <body>
    <div id="content">
      <div id="body-wrap">
      		<div class="page-wide">
	            <div class="page-left-split">
           		    <h1 class="documentation">reference</h1> <ul class="docsadvanced"><li><a href="documentation">basic</a></li> <li><a class="active" href="doxygen/annotated.html">advanced</a></li> </ul>
           		</div>
		        <div class="page-right-narrow">
			        <p>This documentation is automatically generated from the openFrameworks source code using doxygen and refers to the most recent release, version <strong>0.11.1</strong>.</p>
		        </div>
       		</div>
      		<div class="page-wide">
      		    <div class="doxy-mainmenu">
<!-- Generated by Doxygen 1.9.1 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> |
<a href="classof_thread_channel-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ofThreadChannel&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Safely send data between threads without additional synchronization.  
 <a href="classof_thread_channel.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="of_thread_channel_8h_source.html">ofThreadChannel.h</a>&gt;</code></p>
<table class="memberdecls">
<tbody><tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac79bc884d85268a505f2be51aeac3026"><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_thread_channel.html#ac79bc884d85268a505f2be51aeac3026">ofThreadChannel</a> ()</td></tr>
<tr class="memdesc:ac79bc884d85268a505f2be51aeac3026"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a default <a class="el" href="classof_thread_channel.html" title="Safely send data between threads without additional synchronization.">ofThreadChannel</a>.  <a href="classof_thread_channel.html#ac79bc884d85268a505f2be51aeac3026">More...</a><br/></td></tr>
<tr class="separator:ac79bc884d85268a505f2be51aeac3026"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ab0ec065ab911ac8932ebec5ba38631a9"><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_thread_channel.html#ab0ec065ab911ac8932ebec5ba38631a9">receive</a> (T &amp;sentValue)</td></tr>
<tr class="memdesc:ab0ec065ab911ac8932ebec5ba38631a9"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Block the receiving thread until a new sent value is available.  <a href="classof_thread_channel.html#ab0ec065ab911ac8932ebec5ba38631a9">More...</a><br/></td></tr>
<tr class="separator:ab0ec065ab911ac8932ebec5ba38631a9"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a15f344aab7986a00a1dc04033f70d067"><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_thread_channel.html#a15f344aab7986a00a1dc04033f70d067">tryReceive</a> (T &amp;sentValue)</td></tr>
<tr class="memdesc:a15f344aab7986a00a1dc04033f70d067"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If available, receive a new sent value without blocking.  <a href="classof_thread_channel.html#a15f344aab7986a00a1dc04033f70d067">More...</a><br/></td></tr>
<tr class="separator:a15f344aab7986a00a1dc04033f70d067"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a3ee7f9bd6509f050fa0647968227b467"><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_thread_channel.html#a3ee7f9bd6509f050fa0647968227b467">tryReceive</a> (T &amp;sentValue, int64_t timeoutMs)</td></tr>
<tr class="memdesc:a3ee7f9bd6509f050fa0647968227b467"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If available, receive a new sent value or wait for a user-specified duration.  <a href="classof_thread_channel.html#a3ee7f9bd6509f050fa0647968227b467">More...</a><br/></td></tr>
<tr class="separator:a3ee7f9bd6509f050fa0647968227b467"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aeb559f365f7fee7a6bdc6322e30683a5"><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_thread_channel.html#aeb559f365f7fee7a6bdc6322e30683a5">send</a> (const T &amp;value)</td></tr>
<tr class="memdesc:aeb559f365f7fee7a6bdc6322e30683a5"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send a value to the receiver by making a copy.  <a href="classof_thread_channel.html#aeb559f365f7fee7a6bdc6322e30683a5">More...</a><br/></td></tr>
<tr class="separator:aeb559f365f7fee7a6bdc6322e30683a5"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aca886ede85aeeec6eae19516ac9e05d2"><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_thread_channel.html#aca886ede85aeeec6eae19516ac9e05d2">send</a> (T &amp;&amp;value)</td></tr>
<tr class="memdesc:aca886ede85aeeec6eae19516ac9e05d2"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send a value to the receiver without making a copy.  <a href="classof_thread_channel.html#aca886ede85aeeec6eae19516ac9e05d2">More...</a><br/></td></tr>
<tr class="separator:aca886ede85aeeec6eae19516ac9e05d2"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a8d3caa95ca10cffbee462cbbe23ab228"><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_thread_channel.html#a8d3caa95ca10cffbee462cbbe23ab228">close</a> ()</td></tr>
<tr class="memdesc:a8d3caa95ca10cffbee462cbbe23ab228"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close the <a class="el" href="classof_thread_channel.html" title="Safely send data between threads without additional synchronization.">ofThreadChannel</a>.  <a href="classof_thread_channel.html#a8d3caa95ca10cffbee462cbbe23ab228">More...</a><br/></td></tr>
<tr class="separator:a8d3caa95ca10cffbee462cbbe23ab228"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a1488e97723c04c2c382d000b3f4613f1"><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classof_thread_channel.html#a1488e97723c04c2c382d000b3f4613f1">empty</a> () const</td></tr>
<tr class="memdesc:a1488e97723c04c2c382d000b3f4613f1"><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Queries empty channel.  <a href="classof_thread_channel.html#a1488e97723c04c2c382d000b3f4613f1">More...</a><br/></td></tr>
<tr class="separator:a1488e97723c04c2c382d000b3f4613f1"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
</tbody></table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br/>
class ofThreadChannel&lt; T &gt;</h3>

<p>Safely send data between threads without additional synchronization. </p>
<p><a class="el" href="classof_thread_channel.html" title="Safely send data between threads without additional synchronization.">ofThreadChannel</a> makes it easy to safely and efficiently share data between threads without the need for shared memory, mutexes, or other synchronization techniques. Additionally, <a class="el" href="classof_thread_channel.html" title="Safely send data between threads without additional synchronization.">ofThreadChannel</a> employs a signalling system that allows receiving threads to sleep until new data arrives or the <a class="el" href="classof_thread_channel.html" title="Safely send data between threads without additional synchronization.">ofThreadChannel</a> is closed.</p>
<p>A single <a class="el" href="classof_thread_channel.html" title="Safely send data between threads without additional synchronization.">ofThreadChannel</a> class is designed for one-way communication. In most cases an additional <a class="el" href="classof_thread_channel.html" title="Safely send data between threads without additional synchronization.">ofThreadChannel</a> can be used for two-way communication.</p>
<p>Data is sent through the <a class="el" href="classof_thread_channel.html" title="Safely send data between threads without additional synchronization.">ofThreadChannel</a> in a FIFO (first in, first out) order, guaranteeing that that data will be received in the same order that it was sent.</p>
<p>If multiple threads attempt to send data using the same <a class="el" href="classof_thread_channel.html" title="Safely send data between threads without additional synchronization.">ofThreadChannel</a>, the send method will block the calling thread until it is free.</p>
<dl class="section see"><dt>See also</dt><dd><a href="https://github.com/openframeworks/ofBook/blob/master/chapters/threads/chapter.md">https://github.com/openframeworks/ofBook/blob/master/chapters/threads/chapter.md</a> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tbody><tr><td class="paramname">T</td><td>The data type sent by the <a class="el" href="classof_thread_channel.html" title="Safely send data between threads without additional synchronization.">ofThreadChannel</a>. </td></tr>
  </tbody></table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac79bc884d85268a505f2be51aeac3026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac79bc884d85268a505f2be51aeac3026">◆&nbsp;</a></span>ofThreadChannel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname"><a class="el" href="classof_thread_channel.html">ofThreadChannel</a>&lt; T &gt;::<a class="el" href="classof_thread_channel.html">ofThreadChannel</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Create a default <a class="el" href="classof_thread_channel.html" title="Safely send data between threads without additional synchronization.">ofThreadChannel</a>. </p>
<p><a class="el" href="classof_thread_channel.html" title="Safely send data between threads without additional synchronization.">ofThreadChannel</a> must be instantiated with a template parameter such as: </p><div class="fragment"><div class="line"><a class="code" href="classof_thread_channel.html">ofThreadChannel&lt;ofPixels&gt;</a> myThreadChannel;</div>
<div class="ttc" id="aclassof_thread_channel_html"><div class="ttname"><a href="classof_thread_channel.html">ofThreadChannel</a></div><div class="ttdoc">Safely send data between threads without additional synchronization.</div><div class="ttdef"><b>Definition:</b> ofThreadChannel.h:31</div></div>
</div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8d3caa95ca10cffbee462cbbe23ab228"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d3caa95ca10cffbee462cbbe23ab228">◆&nbsp;</a></span>close()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">void <a class="el" href="classof_thread_channel.html">ofThreadChannel</a>&lt; T &gt;::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Close the <a class="el" href="classof_thread_channel.html" title="Safely send data between threads without additional synchronization.">ofThreadChannel</a>. </p>
<p>Closing the <a class="el" href="classof_thread_channel.html" title="Safely send data between threads without additional synchronization.">ofThreadChannel</a> means that no new messages can be sent or received. All threads waiting to receive new values will be notified and all <a class="el" href="classof_thread_channel.html#ab0ec065ab911ac8932ebec5ba38631a9" title="Block the receiving thread until a new sent value is available.">ofThreadChannel::receive</a> and <a class="el" href="classof_thread_channel.html#a15f344aab7986a00a1dc04033f70d067" title="If available, receive a new sent value without blocking.">ofThreadChannel::tryReceive</a> methods will return false. </p>

</div>
</div>
<a id="a1488e97723c04c2c382d000b3f4613f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1488e97723c04c2c382d000b3f4613f1">◆&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool <a class="el" href="classof_thread_channel.html">ofThreadChannel</a>&lt; T &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Queries empty channel. </p>
<p>This call is only an approximation, since messages come from a different thread the channel can return true when calling <a class="el" href="classof_thread_channel.html#a1488e97723c04c2c382d000b3f4613f1" title="Queries empty channel.">empty()</a> and then receive a message right afterwards </p>

</div>
</div>
<a id="ab0ec065ab911ac8932ebec5ba38631a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0ec065ab911ac8932ebec5ba38631a9">◆&nbsp;</a></span>receive()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool <a class="el" href="classof_thread_channel.html">ofThreadChannel</a>&lt; T &gt;::receive </td>
          <td>(</td>
          <td class="paramtype">T &amp;&nbsp;</td>
          <td class="paramname"><em>sentValue</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Block the receiving thread until a new sent value is available. </p>
<p>The receiving thread will block until a new sent value is available. In order to receive data, the user must create an instance of the data type, and pass it to the receive method to be set.</p>
<p><a class="el" href="classof_thread_channel.html#ab0ec065ab911ac8932ebec5ba38631a9" title="Block the receiving thread until a new sent value is available.">ofThreadChannel::receive</a> will not make a copy or reallocate data.</p>
<div class="fragment"><div class="line"><a class="code" href="classof_thread_channel.html">ofThreadChannel&lt;ofPixels&gt;</a> myThreadChannel;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ofThreadChannel&lt;ofPixels&gt; declared elsewhere.</span></div>
<div class="line"> </div>
<div class="line"><a class="code" href="classof_pixels__.html">ofPixels</a> myPixelsToSet;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (myThreadChannel.<a class="code" href="classof_thread_channel.html#ab0ec065ab911ac8932ebec5ba38631a9">receive</a>(myPixelsToSet)) {</div>
<div class="line">    <span class="comment">// If true, `myPixelsToSet` can be used.</span></div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// If false, thread channel was closed and the value of</span></div>
<div class="line">    <span class="comment">// `myPixelsToSet` may be invalid depending on the scope of</span></div>
<div class="line">    <span class="comment">// `myPixelsToSet`.</span></div>
<div class="line">}</div>
<div class="ttc" id="aclassof_pixels___html"><div class="ttname"><a href="classof_pixels__.html">ofPixels_&lt; unsigned char &gt;</a></div></div>
<div class="ttc" id="aclassof_thread_channel_html_ab0ec065ab911ac8932ebec5ba38631a9"><div class="ttname"><a href="classof_thread_channel.html#ab0ec065ab911ac8932ebec5ba38631a9">ofThreadChannel::receive</a></div><div class="ttdeci">bool receive(T &amp;sentValue)</div><div class="ttdoc">Block the receiving thread until a new sent value is available.</div><div class="ttdef"><b>Definition:</b> ofThreadChannel.h:68</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">sentValue</td><td>A reference to a sent value. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if a new value was received or false if the <a class="el" href="classof_thread_channel.html" title="Safely send data between threads without additional synchronization.">ofThreadChannel</a> was closed. </dd></dl>

</div>
</div>
<a id="aeb559f365f7fee7a6bdc6322e30683a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb559f365f7fee7a6bdc6322e30683a5">◆&nbsp;</a></span>send() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool <a class="el" href="classof_thread_channel.html">ofThreadChannel</a>&lt; T &gt;::send </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Send a value to the receiver by making a copy. </p>
<p>This method copies the contents of the sent value, leaving the original data unchanged.</p>
<div class="fragment"><div class="line"><a class="code" href="classof_thread_channel.html">ofThreadChannel&lt;ofPixels&gt;</a> myThreadChannel;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ofThreadChannel&lt;ofPixels&gt; initialized elsewhere.</span></div>
<div class="line"> </div>
<div class="line"><a class="code" href="classof_pixels__.html">ofPixels</a> myPixelsToSend;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fill the pixels with valid data, an image for example.</span></div>
<div class="line"> </div>
<div class="line"><a class="code" href="of_image_8cpp.html#afe8770e91f884a4d37de8529aca65cb2">ofLoadImage</a>(myPixelsToSend, <span class="stringliteral">&#34;myImage.jpg&#34;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Send `myPixelsToSend` by copying it. `myPixelsToSend` is still valid</span></div>
<div class="line"><span class="comment">// after sending.</span></div>
<div class="line"><span class="keywordflow">if</span> (myThreadChannel.<a class="code" href="classof_thread_channel.html#aeb559f365f7fee7a6bdc6322e30683a5">send</a>(myPixelsToSend)) {</div>
<div class="line">    <span class="comment">// If true, `myPixelsToSend` was sent successfully.</span></div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// If false, the thread channel was closed.</span></div>
<div class="line">}</div>
<div class="ttc" id="aclassof_thread_channel_html_aeb559f365f7fee7a6bdc6322e30683a5"><div class="ttname"><a href="classof_thread_channel.html#aeb559f365f7fee7a6bdc6322e30683a5">ofThreadChannel::send</a></div><div class="ttdeci">bool send(const T &amp;value)</div><div class="ttdoc">Send a value to the receiver by making a copy.</div><div class="ttdef"><b>Definition:</b> ofThreadChannel.h:208</div></div>
<div class="ttc" id="aof_image_8cpp_html_afe8770e91f884a4d37de8529aca65cb2"><div class="ttname"><a href="of_image_8cpp.html#afe8770e91f884a4d37de8529aca65cb2">ofLoadImage</a></div><div class="ttdeci">bool ofLoadImage(ofPixels &amp;pix, const std::filesystem::path &amp;path, const ofImageLoadSettings &amp;settings)</div><div class="ttdef"><b>Definition:</b> ofImage.cpp:301</div></div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>true if the value was sent successfully or false if the channel was closed. </dd></dl>

</div>
</div>
<a id="aca886ede85aeeec6eae19516ac9e05d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca886ede85aeeec6eae19516ac9e05d2">◆&nbsp;</a></span>send() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool <a class="el" href="classof_thread_channel.html">ofThreadChannel</a>&lt; T &gt;::send </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&nbsp;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>Send a value to the receiver without making a copy. </p>
<p>This method moves the contents of the sent value using <code>std::move</code> semantics. This avoids copying the data, but the original data data will be invalidated. Note that the original data will be invalideated even if the send fails because the channel is already closed.</p>
<div class="fragment"><div class="line"><a class="code" href="classof_thread_channel.html">ofThreadChannel&lt;ofPixels&gt;</a> myThreadChannel;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ofThreadChannel&lt;ofPixels&gt; initialized elsewhere.</span></div>
<div class="line"> </div>
<div class="line"><a class="code" href="classof_pixels__.html">ofPixels</a> myPixelsToSend;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fill the pixels with valid data, an image for example.</span></div>
<div class="line"> </div>
<div class="line"><a class="code" href="of_image_8cpp.html#afe8770e91f884a4d37de8529aca65cb2">ofLoadImage</a>(myPixelsToSend, <span class="stringliteral">&#34;myImage.jpg&#34;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Send `myPixelsToSend` by moving it. `myPixelsToSend` will no longer</span></div>
<div class="line"><span class="comment">// be valid, even if the send fails because the channel is closed.</span></div>
<div class="line"><span class="keywordflow">if</span> (myThreadChannel.<a class="code" href="classof_thread_channel.html#aeb559f365f7fee7a6bdc6322e30683a5">send</a>(std::move(myPixelsToSend))) {</div>
<div class="line">    <span class="comment">// If true, `myPixelsToSend` was sent successfully.</span></div>
<div class="line">    <span class="comment">// `myPixelsToSend` is no longer valid because it was moved.</span></div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// If false, the thread channel was closed.</span></div>
<div class="line">    <span class="comment">// `myPixelsToSend` is no longer valid because it was moved.</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>true if the value was sent successfully or false if the channel was closed. </dd></dl>

</div>
</div>
<a id="a15f344aab7986a00a1dc04033f70d067"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15f344aab7986a00a1dc04033f70d067">◆&nbsp;</a></span>tryReceive() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool <a class="el" href="classof_thread_channel.html">ofThreadChannel</a>&lt; T &gt;::tryReceive </td>
          <td>(</td>
          <td class="paramtype">T &amp;&nbsp;</td>
          <td class="paramname"><em>sentValue</em></td><td>)</td>
          <td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>If available, receive a new sent value without blocking. </p>
<p><a class="el" href="classof_thread_channel.html#a15f344aab7986a00a1dc04033f70d067" title="If available, receive a new sent value without blocking.">ofThreadChannel::tryReceive</a> is similar to <a class="el" href="classof_thread_channel.html#ab0ec065ab911ac8932ebec5ba38631a9" title="Block the receiving thread until a new sent value is available.">ofThreadChannel::receive</a>, except that it will not block the receiving thread. If no data is available, it will return false and continue immediately.</p>
<p><a class="el" href="classof_thread_channel.html#a15f344aab7986a00a1dc04033f70d067" title="If available, receive a new sent value without blocking.">ofThreadChannel::tryReceive</a> will not make a copy or reallocate data.</p>
<p>Like <a class="el" href="classof_thread_channel.html#ab0ec065ab911ac8932ebec5ba38631a9" title="Block the receiving thread until a new sent value is available.">ofThreadChannel::receive</a>, in order to receive data, the user must create an instance of the data type, and pass it to the receive method to be set.</p>
<div class="fragment"><div class="line"><a class="code" href="classof_thread_channel.html">ofThreadChannel&lt;ofPixels&gt;</a> myThreadChannel;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ofThreadChannel&lt;ofPixels&gt; initialized elsewhere.</span></div>
<div class="line"> </div>
<div class="line"><a class="code" href="classof_pixels__.html">ofPixels</a> myPixelsToSet;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (myThreadChannel.<a class="code" href="classof_thread_channel.html#a15f344aab7986a00a1dc04033f70d067">tryReceive</a>(myPixelsToSet)) {</div>
<div class="line">    <span class="comment">// If true, `myPixelsToSet` can be used.</span></div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// If false, there was no new data OR the thread channel was closed.</span></div>
<div class="line">    <span class="comment">// Either way, the value of `myPixelsToSet` may be invalid depending</span></div>
<div class="line">    <span class="comment">// on the scope of `myPixelsToSet`.</span></div>
<div class="line">}</div>
<div class="ttc" id="aclassof_thread_channel_html_a15f344aab7986a00a1dc04033f70d067"><div class="ttname"><a href="classof_thread_channel.html#a15f344aab7986a00a1dc04033f70d067">ofThreadChannel::tryReceive</a></div><div class="ttdeci">bool tryReceive(T &amp;sentValue)</div><div class="ttdoc">If available, receive a new sent value without blocking.</div><div class="ttdef"><b>Definition:</b> ofThreadChannel.h:115</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">sentValue</td><td>A reference to a sent value. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if a new value was received or false if the <a class="el" href="classof_thread_channel.html" title="Safely send data between threads without additional synchronization.">ofThreadChannel</a> was closed. </dd></dl>

</div>
</div>
<a id="a3ee7f9bd6509f050fa0647968227b467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ee7f9bd6509f050fa0647968227b467">◆&nbsp;</a></span>tryReceive() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tbody><tr>
  <td class="mlabels-left">
      <table class="memname">
        <tbody><tr>
          <td class="memname">bool <a class="el" href="classof_thread_channel.html">ofThreadChannel</a>&lt; T &gt;::tryReceive </td>
          <td>(</td>
          <td class="paramtype">T &amp;&nbsp;</td>
          <td class="paramname"><em>sentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&nbsp;</td>
          <td class="paramname"><em>timeoutMs</em>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </tbody></table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</tbody></table>
</div><div class="memdoc">

<p>If available, receive a new sent value or wait for a user-specified duration. </p>
<p><a class="el" href="classof_thread_channel.html#a15f344aab7986a00a1dc04033f70d067" title="If available, receive a new sent value without blocking.">ofThreadChannel::tryReceive</a> is similar to <a class="el" href="classof_thread_channel.html#ab0ec065ab911ac8932ebec5ba38631a9" title="Block the receiving thread until a new sent value is available.">ofThreadChannel::receive</a>, except that it will block the receiving thread for a maximum of <code>timeoutMs</code> while it waits for sent data. If no data is available during that time, it will return false and continue.</p>
<p><a class="el" href="classof_thread_channel.html#a15f344aab7986a00a1dc04033f70d067" title="If available, receive a new sent value without blocking.">ofThreadChannel::tryReceive</a> will not make a copy or reallocate data.</p>
<p>Like <a class="el" href="classof_thread_channel.html#ab0ec065ab911ac8932ebec5ba38631a9" title="Block the receiving thread until a new sent value is available.">ofThreadChannel::receive</a>, in order to receive data, the user must create an instance of the data type, and pass it to the receive method to be set.</p>
<div class="fragment"><div class="line"><a class="code" href="classof_thread_channel.html">ofThreadChannel&lt;ofPixels&gt;</a> myThreadChannel;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ofThreadChannel&lt;ofPixels&gt; initialized elsewhere.</span></div>
<div class="line"> </div>
<div class="line"><a class="code" href="classof_pixels__.html">ofPixels</a> myPixelsToSet;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (myThreadChannel.<a class="code" href="classof_thread_channel.html#a15f344aab7986a00a1dc04033f70d067">tryReceive</a>(myPixelsToSet)) {</div>
<div class="line">    <span class="comment">// If true, `myPixelsToSet` can be used.</span></div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// If false, there was no new data OR the thread channel was closed.</span></div>
<div class="line">    <span class="comment">// Either way, the value of `myPixelsToSet` may be invalid depending</span></div>
<div class="line">    <span class="comment">// on the scope of `myPixelsToSet`.</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tbody><tr><td class="paramname">sentValue</td><td>A reference to a sent value. </td></tr>
    <tr><td class="paramname">timeoutMs</td><td>The number of milliseconds to wait for new data before continuing. </td></tr>
  </tbody></table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if a new value was received or false if the <a class="el" href="classof_thread_channel.html" title="Safely send data between threads without additional synchronization.">ofThreadChannel</a> was closed. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/Users/anotherenergy/oF/libs/openFrameworks/utils/<a class="el" href="of_thread_channel_8h_source.html">ofThreadChannel.h</a></li>
</ul>
</div><!-- contents -->

            </div>
      </div>
      <div id="footer">
        <a href="http://openframeworks.cc/">openFrameworks</a> Documentation, generated by Doxygen.
      </div> <!-- End Footer -->
    </div> <!-- End Content -->
  

</body></html>